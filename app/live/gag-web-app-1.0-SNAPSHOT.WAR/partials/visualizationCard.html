<div class="card">
	<div class="sensor-adjustments" style="margin-bottom: 40px; margin-top: -20px;">
		<table border="1" style="width:100%; text-align: center;">
			<tr>
				<th>Joint</th>
				<th>X</th>
				<th>Y</th>
				<th>Z</th>
			</tr>
			<tr>
				<td>Wrist</td>
				<td>
<!--					<input type="range" id="wrist-x" min="-180" max="180" value="0">-->
					<input type="range" id="wrist-x" min="-180" max="180" value="0"
						   oninput="document.getElementById('wrist-x-num').value = this.value;">
					<input type="number" id="wrist-x-num" min="-180" max="180" value="0"
						   oninput="document.getElementById('wrist-x').value = this.value;">
				</td>
				<td><input type="range" id="wrist-y" min="-180" max="180" value="0"></td>
				<td><input type="range" id="wrist-z" min="-180" max="180" value="0"></td>
			</tr>
			<tr>
				<td>Thumb</td>
				<td><input type="range" id="thumb-x" min="-180" max="180" value="0"></td>
				<td><input type="range" id="thumb-y" min="-180" max="180" value="0"></td>
				<td><input type="range" id="thumb-z" min="-180" max="180" value="0"></td>
			</tr>
			<tr>
				<td>Index</td>
				<td><input type="range" id="index-x" min="-180" max="180" value="0"></td>
				<td><input type="range" id="index-y" min="-180" max="180" value="0"></td>
				<td><input type="range" id="index-z" min="-180" max="180" value="0"></td>
			</tr>
			<tr>
				<td>Middle</td>
				<td><input type="range" id="middle-x" min="-180" max="180" value="0"></td>
				<td><input type="range" id="middle-y" min="-180" max="180" value="0"></td>
				<td><input type="range" id="middle-z" min="-180" max="180" value="0"></td>
			</tr>
			<tr>
				<td>Ring</td>
				<td><input type="range" id="ring-x" min="-180" max="180" value="0"></td>
				<td><input type="range" id="ring-y" min="-180" max="180" value="0"></td>
				<td><input type="range" id="ring-z" min="-180" max="180" value="0"></td>
			</tr>
			<tr>
				<td>Little</td>
				<td><input type="range" id="little-x" min="-180" max="180" value="0"></td>
				<td><input type="range" id="little-y" min="-180" max="180" value="0"></td>
				<td><input type="range" id="little-z" min="-180" max="180" value="0"></td>
			</tr>
		</table>
	</div>

	<div class="card-header card-header-primary">
		<h4 class="card-title">Live</h4>
		<p class="card-category">{{selectedGestureDetail.info}}</p>
	</div>
	<div class="card-body">
		<div ng-if="ble.isConnected"></div>
		<div class="pusher">
			<main id="main" class="ui green tertiary inverted segment">
<!--				<section class="ui blue pilled message">Vis</section>-->
				<section id="container" style="width: 350px; height: 300px;"></section>
			</main>
		</div>
		<progress style="background: #ab47bc; width: 100%; height: 5px;" id="player-progress" max="100"
				  value="{{vis.currentGesture.progressPercentage*100.0}}"></progress>
		<table class="table">
			<thead class="text-primary">
			<th>ID</th>
			<th>Time</th>
			<th>Position</th>
			</thead>
			<tbody>
			<tr ng-repeat="item in selectedGestureList.data">
				<td>{{item.id}}</td>
				<td>{{item.t | date: 'yyyy-MM-dd HH:MM'}}</td>
				<td>{{item.p}}</td>
			</tr>
			</tbody>
		</table>
	</div>

<!--	<script src="https://cdn.jsdelivr.net/npm/three@0.139.2/build/three.min.js"></script>-->
	<script src="./js/three.min.js"></script>
	<script src="./js/visualization.js"></script>

	<!--<script type="module">-->
	<script>
		console.log("Initializing visualizationCard");
		// import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.139.2/build/three.module.js';
		// document.addEventListener("DOMContentLoaded", function () {
		// $( document ).ready(function() {
		initVis = function() {
			console.log("Initializing visualization.js");
			const container = document.getElementById('container');

			// Scene setup
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x000000);
			const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(container.clientWidth, container.clientHeight);
			container.appendChild(renderer.domElement);

			// Lights
			const light = new THREE.DirectionalLight(0xffffff, 2);
			light.position.set(5, 5, 5).normalize();
			scene.add(light);
			const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
			scene.add(ambientLight);

			// Create hand skeleton function
			const material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
			const createFinger = (base, tip) => {
				const geometry = new THREE.BufferGeometry().setFromPoints([base, tip]);
				return new THREE.Line(geometry, material);
			};

			const createHandSkeleton = (offsetX, rotateY = 0) => {
				const handSkeleton = new THREE.Group();

				// Create a wrist joint that will act as the rotation pivot
				const wristJoint = new THREE.Object3D();
				wristJoint.position.set(offsetX, 0, 0);
				handSkeleton.add(wristJoint); // Attach wrist to handSkeleton

				const fingers = {
					thumb: { base: new THREE.Vector3(-0.4, 0.8, 0), length: 0.6 },
					index: { base: new THREE.Vector3(-0.2, 1.0, 0), length: 0.8 },
					middle: { base: new THREE.Vector3(0, 1.0, 0), length: 1.0 },
					ring: { base: new THREE.Vector3(0.2, 1.0, 0), length: 0.9 },
					little: { base: new THREE.Vector3(0.4, 1.0, 0), length: 0.6 }
				};

				wristJoint.fingers = {};

				Object.keys(fingers).forEach(finger => {
					const baseJoint = new THREE.Object3D();
					baseJoint.position.copy(fingers[finger].base);
					const tipJoint = new THREE.Object3D();
					baseJoint.add(tipJoint);

					const baseLine = createFinger(new THREE.Vector3(0, 0, 0), fingers[finger].base);
					const tipLine = createFinger(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, fingers[finger].length, 0));
					tipJoint.add(tipLine);

					wristJoint.add(baseLine);
					wristJoint.add(baseJoint);
					wristJoint.fingers[finger] = { baseJoint, tipJoint };
				});

				handSkeleton.wristJoint = wristJoint; // Store wristJoint inside the handSkeleton for reference
				// handSkeleton.y += rotateY; // Rotate wrist by default for left hand

				return handSkeleton;
			};
			// window.rightHandSkeleton.setRotationFromQuaternion(new THREE.Quaternion(0.121704, 0.0247192, 0.012085, 0.0072631));
			// window.rightHandSkeleton.rotation.x += Math.PI;
			// Create both hands
			const leftHand = createHandSkeleton(1.2, Math.PI); // Rotate left hand by 180 degrees
			const rightHand = createHandSkeleton(1.2);
			scene.add(leftHand);
			scene.add(rightHand);

			window.leftHandSkeleton = leftHand;
			window.rightHandSkeleton = rightHand;
			window.leftHandSkeleton.rotation.y += Math.PI;
			// window.rightHandSkeleton.rotation.y += Math.PI;

			camera.position.z = 3.5;
			camera.position.y = 1;

			// Mouse drag rotation (rotate the scene instead of the hand)
			let isDragging = false;
			let previousMousePosition = { x: 0, y: 0 };
			container.addEventListener("mousedown", (event) => {
				isDragging = true;
				previousMousePosition = { x: event.clientX, y: event.clientY };
			});
			container.addEventListener("mousemove", (event) => {
				if (!isDragging) return;
				let deltaX = event.clientX - previousMousePosition.x;
				let deltaY = event.clientY - previousMousePosition.y;
				scene.rotation.y += deltaX * 0.01;
				scene.rotation.x += deltaY * 0.01;
				previousMousePosition = { x: event.clientX, y: event.clientY };
			});
			container.addEventListener("mouseup", () => { isDragging = false; });
			container.addEventListener("mouseleave", () => { isDragging = false; });

			// Update hand rotations using quaternions
			window.updateHandsVisualization = function (data) {
				if (!window.leftHandSkeleton || !window.rightHandSkeleton) {
					console.error("Hand skeletons are not initialized.");
					return;
				}

				// Update wrist rotations
				const leftWristQuaternion = new THREE.Quaternion(data.lq._x, data.lq._y, data.lq._z, data.lq._w);
				const rightWristQuaternion = new THREE.Quaternion(data.rq._x, data.rq._y, data.rq._z, data.rq._w);
				window.leftHandSkeleton.setRotationFromQuaternion(leftWristQuaternion);
				window.rightHandSkeleton.setRotationFromQuaternion(rightWristQuaternion);

				window.leftHandSkeleton.rotation.y += Math.PI;

				// Update fingers
				const fingers = ["thumb", "index", "middle", "ring", "little"];
				const leftFingerData = [data.lqt, data.lqi, data.lqm, data.lqr, data.lql];
				const rightFingerData = [data.rqt, data.rqi, data.rqm, data.rqr, data.rql];

				fingers.forEach((finger, index) => {
					if (window.leftHandSkeleton.wristJoint.fingers[finger]) {
						const leftQuat = new THREE.Quaternion(leftFingerData[index]._x, leftFingerData[index]._y, leftFingerData[index]._z, leftFingerData[index]._w);
						window.leftHandSkeleton.wristJoint.fingers[finger].tipJoint.setRotationFromQuaternion(leftQuat);
					}
					if (window.rightHandSkeleton.wristJoint.fingers[finger]) {
						const rightQuat = new THREE.Quaternion(rightFingerData[index]._x, rightFingerData[index]._y, rightFingerData[index]._z, rightFingerData[index]._w);
						window.rightHandSkeleton.wristJoint.fingers[finger].tipJoint.setRotationFromQuaternion(rightQuat);
					}
				});
			};

			// Animation loop
			function animate() {
				requestAnimationFrame(animate);
				renderer.render(scene, camera);
			}
			animate();
		};
		setTimeout(() => {
			console.log("Executing last...");
			initVis();
		}, 1);
	</script>


</div>
