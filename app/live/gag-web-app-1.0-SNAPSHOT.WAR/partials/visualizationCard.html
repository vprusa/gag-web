<div class="card">

	<div class="card-header card-header-primary">
		<h4 class="card-title">Live</h4>
		<p class="card-category">{{selectedGestureDetail.info}}</p>
	</div>
	<div class="card-body">
		<div ng-if="ble.isConnected"></div>
		<div class="pusher">
			<main id="main" class="ui green tertiary inverted segment">
<!--				<section class="ui blue pilled message">Vis</section>-->
				<section id="container" style="width: 100%; height: 300px;"></section>
			</main>
		</div>
		<progress style="background: #ab47bc; width: 100%; height: 5px;" id="player-progress" max="100"
				  value="{{vis.currentGesture.progressPercentage*100.0}}"></progress>
		<table class="table">
			<thead class="text-primary">
			<th>ID</th>
			<th>Time</th>
			<th>Position</th>
			</thead>
			<tbody>
			<tr ng-repeat="item in selectedGestureList.data">
				<td>{{item.id}}</td>
				<td>{{item.t | date: 'yyyy-MM-dd HH:MM'}}</td>
				<td>{{item.p}}</td>
			</tr>
			</tbody>
		</table>
	</div>

<!--	<script src="https://cdn.jsdelivr.net/npm/three@0.139.2/build/three.min.js"></script>-->
	<script src="./js/three.min.js"></script>
	<script src="./js/visualization.js"></script>

	<!--<script type="module">-->
	<script>
		console.log("Initializing visualizationCard");
		// import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.139.2/build/three.module.js';
		// document.addEventListener("DOMContentLoaded", function () {
		// $( document ).ready(function() {
		initVis = function() {
			console.log("Initializing visualization.js");
			const container = document.getElementById('container');

			// Scene setup
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x000000);
			const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(container.clientWidth, container.clientHeight);
			container.appendChild(renderer.domElement);

			// Lights
			const light = new THREE.DirectionalLight(0xffffff, 2);
			light.position.set(5, 5, 5).normalize();
			scene.add(light);
			const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
			scene.add(ambientLight);

			// Create hand skeleton
			const material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
			const createFinger = (base, tip) => {
				const geometry = new THREE.BufferGeometry().setFromPoints([base, tip]);
				return new THREE.Line(geometry, material);
			};

			const wrist = new THREE.Vector3(0, 0, 0);
			const fingers = {
				thumb: { base: new THREE.Vector3(-0.4, 0.8, 0), length: 0.6 },
				index: { base: new THREE.Vector3(-0.2, 1.0, 0), length: 0.8 },
				middle: { base: new THREE.Vector3(0, 1.0, 0), length: 1.0 },
				ring: { base: new THREE.Vector3(0.2, 1.0, 0), length: 0.9 },
				little: { base: new THREE.Vector3(0.4, 1.0, 0), length: 0.6 }
			};

			const handSkeleton = new THREE.Group();
			handSkeleton.fingers = {}; // Store fingers in handSkeleton

			Object.keys(fingers).forEach(finger => {
				const baseJoint = new THREE.Object3D();
				baseJoint.position.copy(fingers[finger].base);
				const tipJoint = new THREE.Object3D();
				// tipJoint.position.y = fingers[finger].length;
				baseJoint.add(tipJoint);

				const baseLine = createFinger(wrist, fingers[finger].base);
				const tipLine = createFinger(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, fingers[finger].length, 0));
				tipJoint.add(tipLine);

				handSkeleton.add(baseLine);
				handSkeleton.add(baseJoint);

				handSkeleton.fingers[finger] = { baseJoint, tipJoint };
			});

			scene.add(handSkeleton);
			window.handSkeleton = handSkeleton; // Store globally for updates
			camera.position.z = 5;

			// Mouse drag rotation
			let isDragging = false;
			let previousMousePosition = { x: 0, y: 0 };
			container.addEventListener("mousedown", (event) => {
				isDragging = true;
				previousMousePosition = { x: event.clientX, y: event.clientY };
			});
			container.addEventListener("mousemove", (event) => {
				if (!isDragging) return;
				let deltaX = event.clientX - previousMousePosition.x;
				let deltaY = event.clientY - previousMousePosition.y;
				handSkeleton.rotation.y += deltaX * 0.01;
				handSkeleton.rotation.x += deltaY * 0.01;
				previousMousePosition = { x: event.clientX, y: event.clientY };
			});
			container.addEventListener("mouseup", () => { isDragging = false; });
			container.addEventListener("mouseleave", () => { isDragging = false; });

			// Animation loop
			function animate() {
				requestAnimationFrame(animate);
				renderer.render(scene, camera);
			}
			animate();
		};
		setTimeout(() => {
			console.log("Executing last...");
			initVis();
		}, 1);
	</script>


</div>
